{
  "hash": "edd618c4d92e1598f5078c0a0bb5407a",
  "result": {
    "markdown": "---\ntitle: Deep Learning from the ground up - From tensor to multi-layer perceptron\nsubtitle: 'Lesson 9 - 14 of fast.ai course, part 2'\nauthor: Pham Nguyen Hung\ndraft: false\ndate: last-modified\ncategories:\n  - code\n  - From scratch\nformat:\n  html:\n    toc: true\n    code-fold: false\n---\n\nI have finished and fallen in love with fast.ai course 1. It has been very informative. It showed me the rope about PyTorch and two important building blocks of deep learning: Embedding and Convolution. I was excited to learn that there was a part 2. In this part, Jeremy will dive deeper into the design of a deep learning framework, and implement one from the scratch the way PyTorch was designed. Here were my (verbose) writtent version for it.\n\n# Rules\n\n- Permitted at the beginning: Python and all standard libraries, matplotlib, Jupyter Notebook and nbdev.\n- After deriving something, we can use the implemented version for that.\n\n# Get the data\nThe first thing you need to do is getting the data and visualize it in some way. The data we use is the good ol' MNIST, available from the Internet. Based on good practice, let's assign the URL to a variable, and prepare a directory to store the data.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nfrom pathlib import Path\nimport pickle, gzip, math, os, time, shutil, matplotlib as mpl, matplotlib.pyplot as plt\n\nMNIST_URL='https://github.com/mnielsen/neural-networks-and-deep-learning/blob/master/data/mnist.pkl.gz?raw=true'\npath_data = Path('data')\npath_data.mkdir(exist_ok=True)\npath_gz = path_data/'mnist.pkl.gz'\n```\n:::\n\n\n`pathlib.Path` is a handy object as you can do special operations with string to receive a new `Path`, such as the division above. It is more readable than just raw strings.\n\nTo get the data, let's use `urllib.request.urlretrieve`\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nfrom urllib.request import urlretrieve\nif not path_gz.exists(): urlretrieve(MNIST_URL, path_gz)\n```\n:::\n\n\nThe data is compressed in the `.pkl.gz` format, which can be decompressed sequentially with `gzip` and `pickle`.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nwith gzip.open(path_gz, 'rb') as f:\n    ((x_train, y_train), (x_valid, y_valid), (x_test, y_test)) = pickle.load(f, encoding='latin-1')\n```\n:::\n\n\n# Visualize the data\n\nGreat, we have decompressed the data, but what exactly are stored inside these variables?\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nx_train, x_valid, x_test\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n(array([[0., 0., 0., ..., 0., 0., 0.],\n        [0., 0., 0., ..., 0., 0., 0.],\n        [0., 0., 0., ..., 0., 0., 0.],\n        ...,\n        [0., 0., 0., ..., 0., 0., 0.],\n        [0., 0., 0., ..., 0., 0., 0.],\n        [0., 0., 0., ..., 0., 0., 0.]], dtype=float32),\n array([[0., 0., 0., ..., 0., 0., 0.],\n        [0., 0., 0., ..., 0., 0., 0.],\n        [0., 0., 0., ..., 0., 0., 0.],\n        ...,\n        [0., 0., 0., ..., 0., 0., 0.],\n        [0., 0., 0., ..., 0., 0., 0.],\n        [0., 0., 0., ..., 0., 0., 0.]], dtype=float32),\n array([[0., 0., 0., ..., 0., 0., 0.],\n        [0., 0., 0., ..., 0., 0., 0.],\n        [0., 0., 0., ..., 0., 0., 0.],\n        ...,\n        [0., 0., 0., ..., 0., 0., 0.],\n        [0., 0., 0., ..., 0., 0., 0.],\n        [0., 0., 0., ..., 0., 0., 0.]], dtype=float32))\n```\n:::\n:::\n\n\nOkay, they are `numpy.ndarray`. We are not allowed to use `numpy` yet, so we will need to convert it to list. Yep, very sorry about that. But first, uh, let's cheat a bit by checking the shape of the arrays.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nx_train.shape, x_valid.shape, x_test.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n((50000, 784), (10000, 784), (10000, 784))\n```\n:::\n:::\n\n\nOkay, it seems that the $28 \\times 28 $ images are flattened into 784-element arrays. Convert any of the `x`s to a list will yield a big list of lists. It is unnecessary, so let's just take 1 data point.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nx = list(x_train[0])\nx[:10], len(x)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 784)\n```\n:::\n:::\n\n\nTo visualize `x`, we need to convert it into a list of 28 lists, each with 28 elements. Is there a way to do that in Python? I said \"No\", but Jeremy showed that there are at least two ways\n\nFirstly, we can make use of the `yield` keyword, which is used to generate iterators in Python. We want to generate 28 iterators, each containing 28 elements, from `x`. In Python, it is as simple as\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndef chunks(x, size):\n    max_size = len(x)\n    for i in range(0, max_size, size): yield x[i:min(max_size, i+size)]\n\nmpl.rcParams['image.cmap'] = 'gray'\nplt.imshow(list(chunks(x, 28)));\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-8-output-1.png){width=415 height=411}\n:::\n:::\n\n\nSecondly, we can use `itertools.islice`.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nfrom itertools import islice\n\nit = iter(x[:10])\nprint('First',  list(islice(it, 5)))\nprint('Second', list(islice(it, 5)))\nprint('Third',  list(islice(it, 5)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFirst [0.0, 0.0, 0.0, 0.0, 0.0]\nSecond [0.0, 0.0, 0.0, 0.0, 0.0]\nThird []\n```\n:::\n:::\n\n\nSimply, `islice(iterable, stop)` will return a new iterator from the iterable (which can be another iterator), stop at `stop`. Paired with default `start` and `step` of 0 and 1 respectively, it means that `islice(it, 5)` will return an iterator containing the first 5 values of `it`. Now we realize that doing so will also exhaust these first 5 values of `it`, so the next call will call the next 5 values of `it`. Paired with a loop, it works exactly like `chunks()` defined above.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nit = iter(x)\nimg = list(iter(lambda: list(islice(it, 28)), []))\nplt.imshow(img);\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-10-output-1.png){width=415 height=411}\n:::\n:::\n\n\nWork like a charm. A note: that empty list passed in after the lambda function is for the sentinel argument of `iter()`, instructing `iter()` to stop when it encounters the sentinel.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}